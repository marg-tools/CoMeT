<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pin: Instrumentation API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Pin</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Instrumentation API</div>  </div>
<div class="ingroups"><a class="el" href="group__INS__BASIC__API.html">INS: Instruction Object</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#gaf8c8e7d6c9872e80d4571ba461dff870">LEVEL_PINCLIENT::INS_INSTRUMENT_CALLBACK</a> )(INS ins, VOID *v)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PIN_CALLBACK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#gaaff4a98e0ece27fc46c0050b4ae05c6d">LEVEL_PINCLIENT::INS_AddInstrumentFunction</a> (INS_INSTRUMENT_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#ga26d02bff719bf8600421895956804252">LEVEL_PINCLIENT::INS_InsertPredicatedCall</a> (INS ins, <a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> ipoint, AFUNPTR funptr,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#ga74a956a0acde197043d04f4adcde4626">LEVEL_PINCLIENT::INS_InsertCall</a> (INS ins, <a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#ga7907ad8ebd991b9e24df3b3b9cec4cac">LEVEL_PINCLIENT::INS_InsertIfCall</a> (INS ins, <a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#ga952b2b061d3fa8f1cc4d5d59fef53a69">LEVEL_PINCLIENT::INS_InsertThenCall</a> (INS ins, <a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#ga5009833ffeecd9fecd8f842a605bf2a1">LEVEL_PINCLIENT::INS_InsertIfPredicatedCall</a> (INS ins, <a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#ga88f930cbed33fa370c9611cc0183d97b">LEVEL_PINCLIENT::INS_InsertThenPredicatedCall</a> (INS ins, <a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, AFUNPTR funptr,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#gacf731514b88f79344068df5d8e60eacc">LEVEL_PINCLIENT::INS_InsertFillBuffer</a> (INS ins, <a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, BUFFER_ID id,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#ga74a3e0d9a1e35568c28abd9b2ba29e4d">LEVEL_PINCLIENT::INS_InsertFillBufferPredicated</a> (INS ins, <a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, BUFFER_ID id,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__INST__API.html#gaa4e98a83483b18bf47d20cb99b4c24ec">LEVEL_PINCLIENT::INS_InsertFillBufferThen</a> (INS ins, <a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> action, BUFFER_ID id,...)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Use these functions to instrument instructions. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaf8c8e7d6c9872e80d4571ba461dff870"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_INSTRUMENT_CALLBACK" ref="gaf8c8e7d6c9872e80d4571ba461dff870" args=")(INS ins, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID(* <a class="el" href="group__INS__INST__API.html#gaf8c8e7d6c9872e80d4571ba461dff870">LEVEL_PINCLIENT::INS_INSTRUMENT_CALLBACK</a>)(INS ins, VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="INS_INSTRUMENT_CALLBACK"></a></p>
<p>Call back function used to instrument instructions </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaaff4a98e0ece27fc46c0050b4ae05c6d"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_AddInstrumentFunction" ref="gaaff4a98e0ece27fc46c0050b4ae05c6d" args="(INS_INSTRUMENT_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PIN_CALLBACK LEVEL_PINCLIENT::INS_AddInstrumentFunction </td>
          <td>(</td>
          <td class="paramtype">INS_INSTRUMENT_CALLBACK&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a function used to instrument at instruction granularity </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>Instrumentation function for instructions </td></tr>
    <tr><td class="paramname">val</td><td>passed as the second argument to the instrumentation function</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>PIN_CALLBACK A handle to a callback that can be used to further modify this callback's properties</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga74a956a0acde197043d04f4adcde4626"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertCall" ref="ga74a956a0acde197043d04f4adcde4626" args="(INS ins, IPOINT action, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertCall </td>
          <td>(</td>
          <td class="paramtype">INS&#160;</td>
          <td class="paramname"><em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert a call to funptr relative to instruction ins. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ins</td><td>Instruction to instrument </td></tr>
    <tr><td class="paramname">action</td><td>Specifies before, after, etc. <br/>
 IPOINT_BEFORE is always valid for all instructions. <br/>
 IPOINT_AFTER is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). <br/>
 IPOINT_TAKEN_BRANCH is invalid for non-branches. </td></tr>
    <tr><td class="paramname">funptr</td><td>Insert a call to funptr </td></tr>
    <tr><td class="paramname">...</td><td>List of arguments to pass funptr. See <a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>, terminated with IARG_END</td></tr>
  </table>
  </dd>
</dl>
<p>If more than one call is inserted for the same instruction, the order is determined by <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. For more information, see <a class="el" href="group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gacf731514b88f79344068df5d8e60eacc"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertFillBuffer" ref="gacf731514b88f79344068df5d8e60eacc" args="(INS ins, IPOINT action, BUFFER_ID id,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertFillBuffer </td>
          <td>(</td>
          <td class="paramtype">INS&#160;</td>
          <td class="paramname"><em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BUFFER_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert analysis code to fill one record in a trace buffer whenever an application instruction executes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ins</td><td>The application instruction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>Tells whether the record is filled before or after the instruction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The ID of the buffer whose record is filled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td><a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. Additional arguments to specify the fields of the trace buffer. These additional arguments take the form: IARG_TYPE arg, [optional IARG parameters], size_t offset, ..., IARG_END The  arg argument specifies the value to write to the trace record field. The  offset argument specifies the offset (in bytes) from the start of the trace record to this field. Typically, you would use "offsetof()" for this. if  arg requires additional parameters, they come before  offset.</td></tr>
  </table>
  </dd>
</dl>
<p>Certain IARG_TYPEs cannot be used with the *_InsertFillBuffer APIs. The unsupported IARG_TYPEs are: IARG_CONTEXT, IARG_REG_REFERENCE, and IARG_REG_CONST_REFERENCE.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux &amp; Windows<br/>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga74a3e0d9a1e35568c28abd9b2ba29e4d"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertFillBufferPredicated" ref="ga74a3e0d9a1e35568c28abd9b2ba29e4d" args="(INS ins, IPOINT action, BUFFER_ID id,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertFillBufferPredicated </td>
          <td>(</td>
          <td class="paramtype">INS&#160;</td>
          <td class="paramname"><em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BUFFER_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert analysis code to fill one record in a trace buffer whenever an application instruction executes, based on that instruction's predicate.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ins</td><td>The application instruction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>Whether the record is filled before or after the instruction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The ID of the buffer whose record is filled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td><a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. Additional arguments to specify the fields of the trace buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Certain IARG_TYPEs cannot be used with the *_InsertFillBuffer APIs. The unsupported IARG_TYPEs are: IARG_CONTEXT, IARG_REG_REFERENCE, and IARG_REG_CONST_REFERENCE.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux &amp; Windows<br/>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4e98a83483b18bf47d20cb99b4c24ec"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertFillBufferThen" ref="gaa4e98a83483b18bf47d20cb99b4c24ec" args="(INS ins, IPOINT action, BUFFER_ID id,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertFillBufferThen </td>
          <td>(</td>
          <td class="paramtype">INS&#160;</td>
          <td class="paramname"><em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BUFFER_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert analysis code to fill one record in a trace buffer whenever an application instruction executes. The record is only inserted if the preceding "if" analysis call returns a non-zero value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ins</td><td>The application instruction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>Whether the record is filled before or after the instruction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The ID of the buffer whose record is to filled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td><a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>. Additional arguments to specify the fields of the trace buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>Certain IARG_TYPEs cannot be used with the *_InsertFillBuffer APIs. The unsupported IARG_TYPEs are: IARG_CONTEXT, IARG_REG_REFERENCE, and IARG_REG_CONST_REFERENCE.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux &amp; Windows<br/>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7907ad8ebd991b9e24df3b3b9cec4cac"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertIfCall" ref="ga7907ad8ebd991b9e24df3b3b9cec4cac" args="(INS ins, IPOINT action, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertIfCall </td>
          <td>(</td>
          <td class="paramtype">INS&#160;</td>
          <td class="paramname"><em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert a call to funptr relative to an INS. If funptr returns a non-zero ADDRINT, then the immediately following "then" analysis call is executed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ins</td><td>Instruction to instrument </td></tr>
    <tr><td class="paramname">action</td><td>Specifies before, after, etc. <br/>
 IPOINT_BEFORE is always valid for all instructions. <br/>
 IPOINT_AFTER is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). <br/>
 IPOINT_TAKEN_BRANCH is invalid for non-branches. <br/>
 IPOINT_ANYWHERE is not supported and will result an error. <br/>
 action value must be identical to the value passed to the corresponding <a class="el" href="group__INS__INST__API.html#ga952b2b061d3fa8f1cc4d5d59fef53a69">INS_InsertThenCall</a>. </td></tr>
    <tr><td class="paramname">funptr</td><td>Insert a call to funptr. Its return type must be ADDRINT </td></tr>
    <tr><td class="paramname">...</td><td>List of arguments to pass funptr. See <a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>, terminated with IARG_END</td></tr>
  </table>
  </dd>
</dl>
<p>If more than one call is inserted for the same instruction, the order is determined by <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. For more information, see <a class="el" href="group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>. Note that if <a class="el" href="group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a> is used, Both "if" and "then" analysis calls must have the same order.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5009833ffeecd9fecd8f842a605bf2a1"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertIfPredicatedCall" ref="ga5009833ffeecd9fecd8f842a605bf2a1" args="(INS ins, IPOINT action, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertIfPredicatedCall </td>
          <td>(</td>
          <td class="paramtype">INS&#160;</td>
          <td class="paramname"><em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert a call to funptr relative to an INS. If funptr returns a non-zero ADDRINT and the instruction has a true predicate, then the immediately following "then" analysis call is executed. If the instruction is not predicated, then this function is identical to <a class="el" href="group__INS__INST__API.html#ga7907ad8ebd991b9e24df3b3b9cec4cac">INS_InsertIfCall</a>.</p>
<p>Note that funptr <em>may</em> be called even if the predicate is false, the predicate is only defined to guard the execution of the following THEN function. (So if the function inserted here modifies the machine state it might affect the value of the predicate. Best practice is not to modify machine state here!)</p>
<p>On IA32 and Intel64, the sequences </p>
<div class="fragment"><pre class="fragment">     <a class="code" href="group__INS__INST__API.html#ga7907ad8ebd991b9e24df3b3b9cec4cac">INS_InsertIfCall</a>(...);
     <a class="code" href="group__INS__INST__API.html#ga88f930cbed33fa370c9611cc0183d97b">INS_InsertThenPredicatedCall</a>(...);
</pre></div> <div class="fragment"><pre class="fragment">     <a class="code" href="group__INS__INST__API.html#ga5009833ffeecd9fecd8f842a605bf2a1">INS_InsertIfPredicatedCall</a>(...);
     <a class="code" href="group__INS__INST__API.html#ga952b2b061d3fa8f1cc4d5d59fef53a69">INS_InsertThenCall</a>(...);
</pre></div><p> and </p>
<div class="fragment"><pre class="fragment">     <a class="code" href="group__INS__INST__API.html#ga5009833ffeecd9fecd8f842a605bf2a1">INS_InsertIfPredicatedCall</a>(...);
     <a class="code" href="group__INS__INST__API.html#ga88f930cbed33fa370c9611cc0183d97b">INS_InsertThenPredicatedCall</a>(...);
</pre></div><p>produce identical results. They all generate code which can be represented like this </p>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (UsersIfFunction(...))
          <span class="keywordflow">if</span> (predicate)
              UsersThenFunction(...);
</pre></div><p> However on other architectures the behavior may be different, and the "IF" call need not always be called.</p>
<p>This means that on IA32 and Intel64 the user's IF code is always called, however on these architectures that is very likely to generate faster code, since predicated instructions are rare. The dynamically most important predicated instructions are almost certainly REP MOVS, which have a very low (~80ppm) probablity of being predicated false. Unless the user's IF code is very large, or has a lower probability of filtering the execution, it is always better to use the test of the user condition to prevent execution of the predicate test. Of course, the code included in a user IF call is expected to be small, since the objective of INS_InsertIfCall, INS_InsertThenCall is to allow the code in the IF to be inlined.</p>
<p>If you need to know the instruction predicate inside the IF call, you should pass IARG_EXECUTING as an argument and test it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ins</td><td>Instruction to instrument </td></tr>
    <tr><td class="paramname">action</td><td>Specifies before, after, etc. <br/>
 <a class="el" href="group__INST__ARGS.html#gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a> is always valid for all instructions. <br/>
 <a class="el" href="group__INST__ARGS.html#gga707ea08e31f44f4a81e2a7766123bad7a42eff26179c6d87348abe492301c12ec">IPOINT_AFTER</a> is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). <br/>
 <a class="el" href="group__INST__ARGS.html#gga707ea08e31f44f4a81e2a7766123bad7a5ef5b45901a8447e5173f50746ab029d">IPOINT_TAKEN_BRANCH</a> is invalid for non-branches. </td></tr>
    <tr><td class="paramname">funptr</td><td>Insert a call to funptr. Its return type must be ADDRINT </td></tr>
    <tr><td class="paramname">...</td><td>List of arguments to pass funptr. See <a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>, terminated with IARG_END</td></tr>
  </table>
  </dd>
</dl>
<p>If more than one call is inserted for the same instruction, the order is determined by <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. For more information, see <a class="el" href="group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>. Note that if <a class="el" href="group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a> is used, Both "if" and "then" analysis calls must have the same order.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga26d02bff719bf8600421895956804252"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertPredicatedCall" ref="ga26d02bff719bf8600421895956804252" args="(INS ins, IPOINT ipoint, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertPredicatedCall </td>
          <td>(</td>
          <td class="paramtype">INS&#160;</td>
          <td class="paramname"><em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&#160;</td>
          <td class="paramname"><em>ipoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>See <a class="el" href="group__INS__INST__API.html#ga74a956a0acde197043d04f4adcde4626">INS_InsertCall</a>. When the instruction has a predicate and the predicate is false, the analysis function is not called.</p>
<p>On the IA-32 and Intel 64 architectures the only instructions treated as predicated are CMOVcc, FCMOVcc and REPped string ops. For the conditional moves, the predicate is based on the condition codes tested by the instruction. For the REPped string ops the predicate is that the execution count is not zero. For all other instructions the predicate is always true, so INS_InsertPredicatedCall is identical to <a class="el" href="group__INS__INST__API.html#ga74a956a0acde197043d04f4adcde4626">INS_InsertCall</a>.</p>
<p>If you want to test both your own condition, and the predicate, you can use <a class="el" href="group__INS__INST__API.html#ga88f930cbed33fa370c9611cc0183d97b">INS_InsertThenPredicatedCall</a>, or use <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da5f291cb55a7d61a40fa3ab98e191394e">IARG_EXECUTING</a> to pass the predicate value to an <a class="el" href="group__INS__INST__API.html#ga7907ad8ebd991b9e24df3b3b9cec4cac">INS_InsertIfCall</a>.</p>
<p>If more than one call is inserted for the same instruction, the order is determined by <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. For more information, see <a class="el" href="group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga952b2b061d3fa8f1cc4d5d59fef53a69"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertThenCall" ref="ga952b2b061d3fa8f1cc4d5d59fef53a69" args="(INS ins, IPOINT action, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertThenCall </td>
          <td>(</td>
          <td class="paramtype">INS&#160;</td>
          <td class="paramname"><em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert a call to funptr relative to an INS. The function is called only if the immediately preceding "if" analysis call returns a non-zero value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ins</td><td>Instruction to instrument </td></tr>
    <tr><td class="paramname">action</td><td>Specifies before, after, etc. <br/>
 IPOINT_BEFORE is always valid for all instructions. <br/>
 IPOINT_AFTER is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). <br/>
 IPOINT_TAKEN_BRANCH is invalid for non-branches. <br/>
 IPOINT_ANYWHERE is not supported and will result an error. <br/>
 action value must be identical to the value passed to the corresponding <a class="el" href="group__INS__INST__API.html#ga7907ad8ebd991b9e24df3b3b9cec4cac">INS_InsertIfCall</a>. </td></tr>
    <tr><td class="paramname">funptr</td><td>Insert a call to funptr </td></tr>
    <tr><td class="paramname">...</td><td>List of arguments to pass funptr. See <a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>, terminated with IARG_END</td></tr>
  </table>
  </dd>
</dl>
<p>If more than one call is inserted for the same instruction, the order is determined by <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. For more information, see <a class="el" href="group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>. Note that if <a class="el" href="group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a> is used, Both "if" and "then" analysis calls must have the same order.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga88f930cbed33fa370c9611cc0183d97b"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertThenPredicatedCall" ref="ga88f930cbed33fa370c9611cc0183d97b" args="(INS ins, IPOINT action, AFUNPTR funptr,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::INS_InsertThenPredicatedCall </td>
          <td>(</td>
          <td class="paramtype">INS&#160;</td>
          <td class="paramname"><em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFUNPTR&#160;</td>
          <td class="paramname"><em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert a call to funptr relative to an INS. The function is called only if the immediately preceding "if" analysis call returns a non-zero value and the instruction's predicate is true. See <a class="el" href="group__INS__INST__API.html#ga5009833ffeecd9fecd8f842a605bf2a1">INS_InsertIfPredicatedCall</a> for details of the semantics of mixing <a class="el" href="group__INS__INST__API.html#ga88f930cbed33fa370c9611cc0183d97b">INS_InsertThenPredicatedCall</a> with <a class="el" href="group__INS__INST__API.html#ga7907ad8ebd991b9e24df3b3b9cec4cac">INS_InsertIfCall</a> (and all the other possibilities).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ins</td><td>Instruction to instrument </td></tr>
    <tr><td class="paramname">action</td><td>Specifies before, after, etc. <br/>
 IPOINT_BEFORE is always valid for all instructions. <br/>
 IPOINT_AFTER is valid only when a fall-through exists (i.e. Calls and unconditional branches will fail). <br/>
 IPOINT_TAKEN_BRANCH is invalid for non-branches. </td></tr>
    <tr><td class="paramname">funptr</td><td>Insert a call to funptr </td></tr>
    <tr><td class="paramname">...</td><td>List of arguments to pass funptr. See <a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>, terminated with IARG_END</td></tr>
  </table>
  </dd>
</dl>
<p>If more than one call is inserted for the same instruction, the order is determined by <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. For more information, see <a class="el" href="group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>. Note that if <a class="el" href="group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a> is used, Both "if" and "then" analysis calls must have the same order.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux, Windows &amp; OS X*<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue May 8 2018 23:39:04 for Pin by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
